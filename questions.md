### Section 1:

3. What triggers are.

3.
Триггеры — это механизмы в базе данных, которые автоматически выполняют заданные действия при изменении данных (INSERT, UPDATE, DELETE).

Юзкейсы:
Логирование изменений: Запись истории изменений данных в отдельную таблицу.
Проверка данных: Автоматическая валидация данных перед вставкой/обновлением.
Поддержание целостности: Автоматическое обновление связанных таблиц (например, пересчет сумм).

4. Cache algorithms, benefits of using cache, slacks.
LRU (Least Recently Used): Удаляет элемент, который не использовался дольше всего. Подходит для случаев, когда наиболее недавно использованные данные имеют наибольшую вероятность снова быть востребованными.

Юзкейс: Кэш веб-страниц или данных в браузере.
LFU (Least Frequently Used): Удаляет элемент, который использовался реже всего. Подходит для данных, которые используются с определенной регулярностью.

Юзкейс: Кэш запросов к базе данных, где одни запросы встречаются чаще других.
FIFO (First In, First Out): Удаляет самый старый элемент, независимо от его использования. Простой и эффективный, но может быть менее оптимальным.

Юзкейс: Очередь кэшированных изображений или видеофрагментов.
Random Replacement: Удаляет случайный элемент из кэша. Используется в системах с очень низкими ресурсами, где сложные алгоритмы недоступны.

Юзкейс: Простые системы встраиваемых устройств.
MRU (Most Recently Used): Удаляет наиболее недавно использованный элемент, предполагая, что недавний элемент может больше не понадобиться.

Юзкейс: Специфические сценарии, где данные используются одноразово.

5. Replicating (synchronous, asynchronous), reading from 2 disks, sharding.
Мастер-слейв (Master-Slave):
Чтение: Обычно чтение происходит с слейвов, чтобы разгрузить мастер. Это помогает распределить нагрузку на чтение, так как чтения гораздо больше, чем записей.
Запись: Все операции записи выполняются только на мастере. Слейвы получают данные от мастера через репликацию.
Синхронная репликация:
После каждой записи на мастере данные мгновенно синхронизируются на слейвах. Запись считается завершённой только после того, как все слейвы подтвердят запись.
Плюс: Полная консистентность данных между мастером и слейвами.
Минус: Высокие задержки при записи из-за ожидания подтверждений от всех слейвов.
Асинхронная репликация:
Мастер подтверждает запись сразу после завершения операции, не дожидаясь синхронизации со слейвами. Слейвы могут обновляться с небольшой задержкой.
Плюс: Высокая производительность и быстрые операции записи.
Минус: Возможна временная неконсистентность данных между мастером и слейвами.
Итог для мастер-слейв:

Чтение — с слейвов.
Запись — на мастере.
Синхронная: записи медленные, но все данные актуальны на слейвах.
Асинхронная: записи быстрые, но данные на слейвах могут отставать.
2. Мастер-мастер (Master-Master):
Чтение: Чтение может происходить с любого мастера. Это помогает распределить нагрузку, особенно в географически распределённых системах.
Запись: Записи могут производиться на любом мастере. Каждый мастер может записывать данные, и изменения затем синхронизируются с другими мастерами.
Синхронная репликация:
Все изменения, сделанные на одном мастере, немедленно передаются другим мастерам, и запись подтверждается только после того, как все мастера обновят данные.
Плюс: Консистентные данные на всех мастерах.
Минус: Высокие задержки при записи, особенно в распределённых системах.
Асинхронная репликация:
Данные записываются на одном мастере, а синхронизация с другими мастерами происходит с задержкой.
Плюс: Быстрые записи, так как не нужно ждать подтверждений от других мастеров.
Минус: Возможна неконсистентность данных между мастерами, особенно если один и тот же объект обновляется на разных узлах.
Итог для мастер-мастер:

Чтение — с любого мастера.
Запись — на любом мастере.
Синхронная: все мастеры согласованы, но запись медленная.
Асинхронная: запись быстрая, но возможны конфликты и задержки в синхронизации.
Пример с добавлением асинхронной/синхронной репликации:
В мастер-слейв с асинхронной репликацией: данные могут быть записаны на мастере и только через некоторое время будут доступны на слейвах для чтения. Чтение может возвращать старые данные.
В мастер-мастер с синхронной репликацией: данные записываются на одном мастере и моментально реплицируются на другие мастеры. Время записи будет выше, но чтение с любого мастера даст одинаковые данные.

### Section 2:
1. TCP and UDP, warranty of delivery in TCP, TCP handshake.

2. The parts of HTTP.
3. HTTP vs HTTPS, why do we need it.
4. Why do we need timeout.
5. Load balancing algorithms.
6. Client balancing, how to implement it.
7. How browsers work, DNS, what happens when you write a URL.
8. 2 phase, 3 phase, saga.
Round Robin (Круговой метод):

Описание: Каждый новый запрос последовательно направляется на следующий сервер по кругу. Когда последний сервер получает запрос, процесс повторяется с первого сервера.
Плюсы: Простота и равномерное распределение нагрузки.
Минусы: Не учитывает текущую загрузку серверов, что может привести к перегрузке одного из них.
Юзкейс: Подходит для однородных серверов с одинаковыми характеристиками и низкими требованиями к обработке.
Weighted Round Robin (Взвешенный круговой метод):

Описание: Каждый сервер получает вес (коэффициент), определяющий его относительную производительность или доступные ресурсы. Серверы с большим весом получают больше запросов.
Плюсы: Учитывает разницу в мощностях серверов.
Минусы: Может не учесть текущую динамическую нагрузку на сервер.
Юзкейс: Подходит для систем с серверами разной мощности или для облачных сред.
Least Connections (Наименьшее количество соединений):

Описание: Запрос направляется на сервер, у которого на данный момент наименьшее количество активных соединений.
Плюсы: Эффективно при высокой нагрузке, когда важно учитывать, насколько каждый сервер загружен.
Минусы: Не учитывает разницу в производительности серверов.
Юзкейс: Подходит для систем с длинными сеансами соединений (например, базы данных или HTTP-сервисы).
Weighted Least Connections (Взвешенный алгоритм наименьших соединений):

Описание: Как и в стандартном алгоритме наименьших соединений, запрос направляется серверу с наименьшим количеством соединений, но с учётом веса каждого сервера.
Плюсы: Учитывает разницу в мощности серверов и текущую загрузку.
Минусы: Требует тщательной настройки весов и мониторинга нагрузки.
Юзкейс: Применяется в системах, где сервера различаются по мощности, и соединения могут быть длительными.
Least Response Time (Наименьшее время отклика):

Описание: Запрос направляется на сервер с наименьшим временем отклика. Время отклика включает как текущую загрузку сервера, так и сетевые задержки.
Плюсы: Быстрая реакция на изменения нагрузки, оптимизация по времени отклика.
Минусы: Может приводить к перегрузке серверов с короткими задержками.
Юзкейс: Подходит для веб-приложений или систем с высокими требованиями к быстрому отклику.
IP Hash:

Описание: Сервер для обработки запроса выбирается на основе хэша IP-адреса клиента. Это означает, что один и тот же клиент будет всегда отправляться на один и тот же сервер.
Плюсы: Обеспечивает устойчивость соединений, что полезно для приложений, где важна сессия (например, онлайн-магазины).
Минусы: Неправильное распределение нагрузки при неоднородной активности клиентов.
Юзкейс: Используется в системах, где необходимо направлять запросы одного клиента на один и тот же сервер.
Random (Случайный выбор):

Описание: Запросы случайным образом распределяются между серверами.
Плюсы: Простота реализации.
Минусы: Не учитывает ни загрузку серверов, ни их производительность, что может привести к неравномерной нагрузке.
Юзкейс: Подходит для распределения запросов в однородной среде с равномерной нагрузкой.
Least Bandwidth (Минимальная пропускная способность):

Описание: Запрос направляется серверу, который использует наименьшую пропускную способность в данный момент времени.
Плюсы: Эффективно при работе с большими объёмами данных.
Минусы: Может требовать сложного мониторинга сетевых ресурсов.
Юзкейс: Используется в системах с высокими требованиями к пропускной способности, например, для потоковой передачи данных.
Least Packets (Минимальное количество пакетов):

Описание: Запрос отправляется серверу, который в данный момент передал наименьшее количество сетевых пакетов.
Плюсы: Полезно для систем с различной нагрузкой по количеству пакетов.
Минусы: Не учитывает текущие ресурсы и активные соединения.
Юзкейс: Применяется в сетях с высокой плотностью пакетов данных (например, DNS-сервера).
Sticky Sessions (Закрепление сессий):

Описание: Запросы одного и того же пользователя (по сессии или cookie) направляются на один и тот же сервер, пока сессия активна.
Плюсы: Обеспечивает сессионную целостность данных, особенно для веб-приложений.
Минусы: Может привести к неравномерной загрузке серверов при высокой активности отдельных пользователей.
Юзкейс: Используется в приложениях, где важно сохранить состояние пользователя на одном сервере, например, в интернет-магазинах.
Выбор алгоритма:
Round Robin и Weighted Round Robin подходят для однородных систем, где серверы имеют одинаковую мощность.
Least Connections и Weighted Least Connections предпочтительны для систем с длительными соединениями и разной нагрузкой на сервера.
IP Hash и Sticky Sessions идеальны для систем, где важно сохранять сессии пользователей на одном сервере.
Least Response Time и Least Bandwidth применимы в системах с высокими требованиями к времени отклика и пропускной способности.

### Section 3:
1. How to kill a process in OS.
2. What happens when we ask to allocate 4KB of memory.
3. What happens when the system cannot allocate memory.
4. Virtual memory.

### Section 4:
1. What a file descriptor is.
2. Inner device of sync.Map.
3. Inner device of the garbage collector.
4. How rate limiters work.
5. How to adjust a rate limiter.
6. Difference between background context and TODO.

### Section 5:
1. How servers scale and how services stay operational.
2. RPS of my services.
3. How to adjust NGINX.
4. How LFU, MFU.
5. 

### Section 6:
1. Tell about the projects (architecture, databases, interaction, RPS, teams, tasks, what you did there, what the services were doing).