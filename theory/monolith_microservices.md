1. [Микросервисная архитектура: лучше монолита, риски и недостатки](#microservice-architecture-vs-monolith)  
2. [Почему микросервисы могут быть лучше монолита](#why-microservices-are-better-than-monolith)  
3. [Риски микросервисов](#risks-of-microservices)  
4. [Когда микросервисы могут быть хуже монолита](#when-microservices-are-worse-than-monolith)  5. [Антипаттерны микросервисов](#antipatterns-of-microservices)  
6. [Распределённый монолит](#distributed-monolith)  
7. [Взрыв сервисов](#service-explosion)  
8. [Смерть от тысячи порезов](#death-by-thousand-cuts)  
9. [API-шлюзы как узкие места](#api-gateways-as-bottlenecks)  
10. [Общая база данных](#shared-database)  
11. [Как избежать антипаттернов](#how-to-avoid-antipatterns)

### Микросервисная архитектура: лучше монолита, риски и недостатки <a id="microservice-architecture-vs-monolith"></a>

#### Почему микросервисы могут быть лучше монолита: <a id="why-microservices-are-better-than-monolith"></a>
1. **Масштабируемость:** Микросервисы позволяют масштабировать отдельные компоненты независимо, что более эффективно, чем масштабирование всего монолита.
2. **Гибкость в выборе технологий:** Каждый сервис может использовать различные технологии, которые лучше всего подходят для его задач, в отличие от монолитной системы, где выбор технологий ограничен общим стеком.
3. **Надежность:** Каждый микросервис имеет реплики, которые в случае чего могут заменить его. Если весь реплика сет упал - система все еще доступна, даже без одного микросервиса.  

#### Риски микросервисов: <a id="risks-of-microservices"></a>
1. **Сложность управления:** С увеличением числа микросервисов управление ими становится значительно сложнее. Нужно организовать мониторинг, логирование, оркестрацию, а также решить проблемы сетевого взаимодействия между сервисами.
2. **Сложность отладки и тестирования:** Отладка распределённых микросервисов сложнее, так как ошибки могут возникать из-за межсервисных взаимодействий. Тестирование также требует больше ресурсов, так как необходимо учитывать сетевые задержки и взаимодействие сервисов.

#### Когда микросервисы могут быть хуже монолита: <a id="when-microservices-are-worse-than-monolith"></a>
1. **Перегрузка инфраструктуры:** Внедрение микросервисов требует сложной инфраструктуры, включая оркестраторы, такие как Kubernetes, и сервисы для балансировки нагрузки и мониторинга. Это может привести к значительным затратам на поддержку.
2. **Избыточная сложность для небольших проектов:** Для малых или средних проектов использование микросервисов может быть чрезмерным, так как монолитная архитектура проще в управлении и требует меньше ресурсов на начальных этапах разработки.

### Антипаттерны микросервисов <a id="antipatterns-of-microservices"></a>

#### a) **Распределённый монолит** <a id="distributed-monolith"></a>
- **Описание**: Несмотря на наличие микросервисов, они тесно связаны между собой, как монолитное приложение, и сильно зависят друг от друга для нормальной работы. Это сводит на нет преимущества микросервисов, так как сохраняются проблемы монолитной архитектуры.
- **Причина**: Плохое определение границ сервисов или недостаточная автономность между ними.
- **Эффект**: Любое изменение в одном микросервисе требует изменений в других. Тестирование и развертывание становятся такими же сложными, как и в монолитных системах.

#### b) **Взрыв сервисов** <a id="service-explosion"></a>
- **Описание**: Когда микросервисы разбиваются на слишком мелкие, слишком специализированные сервисы, это приводит к «взрыву» количества сервисов, которые сложно управлять.
- **Причина**: Чрезмерная декомпозиция, разделение сервисов без учёта их связности и целостности.
- **Эффект**: Усложнение управления, рост затрат на коммуникацию и сложности с управлением взаимодействием между сервисами.

#### c) **Смерть от тысячи порезов** <a id="death-by-thousand-cuts"></a>
- **Описание**: В архитектуре микросервисов каждый сервис работает нормально самостоятельно, но при их объединении производительность или надёжность всей системы ухудшается из-за чрезмерной сетевой коммуникации, множества запросов к базе данных или чрезмерной координации между сервисами.
- **Причина**: Слишком сильная зависимость от межсервисной коммуникации, отсутствие оптимизации для уменьшения задержек и улучшения взаимодействия между сервисами.
- **Эффект**: Возникают задержки, увеличивается количество точек отказа, и сложнее отлаживать систему при сбоях.

#### d) **API-шлюзы как узкие места** <a id="api-gateways-as-bottlenecks"></a>
- **Описание**: Единый API-шлюз становится узким местом для всех запросов, что сводит на нет преимущества микросервисов.
- **Причина**: Централизация слишком большого числа задач в API-шлюзе, выполнение в нём бизнес-логики или оркестрации сервисов.
- **Эффект**: Проблемы с производительностью API-шлюза приводят к простоям или задержкам в работе всех микросервисов.

#### e) **Общая база данных** <a id="shared-database"></a>
- **Описание**: Микросервисы должны быть автономными, но антипаттерн возникает, когда они используют общую базу данных. Это создаёт тесную связанность на уровне базы данных.
- **Причина**: Страх дублирования данных или боязнь проблем с согласованностью данных.
- **Эффект**: Изменения в схеме базы данных затрагивают все микросервисы, что затрудняет их независимое масштабирование и разработку.

### Как избежать этих антипаттернов: <a id="how-to-avoid-antipatterns"></a>
- **В микросервисах**:
  - Чётко определяйте границы между сервисами.
  - Не увлекайтесь излишней декомпозицией — фокусируйтесь на логических границах сервисов.
  - Оптимизируйте коммуникацию между сервисами и снижайте зависимости между ними.
  - Убедитесь, что сервисы слабо связаны и общаются асинхронно, где это возможно.
  - Избегайте единой точки отказа, такой как общая база данных или перегруженный API-шлюз.