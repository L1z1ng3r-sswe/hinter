пример, который иллюстрирует, как Go использует хэш для распределения ключей по бакетам и поиска внутри бакета, и полный текст с включённым объяснением и примером.

### Пример:

```go
package main

import (
	"fmt"
	"hash/fnv"
)

// Симуляция хеширования для ключей
func hashKey(key string) (uint32, uint8) {
	// Используем хеш-функцию FNV для генерации большого хэша
	h := fnv.New32a()
	h.Write([]byte(key))
	fullHash := h.Sum32()        // Большой хэш (full hash)
	smallHash := uint8(fullHash) // Малый хэш (1 байт из полного хэша)

	return fullHash, smallHash
}

func main() {
	key := "exampleKey"

	fullHash, smallHash := hashKey(key)
	fmt.Printf("Полный хэш: %v\n", fullHash)
	fmt.Printf("Малый хэш: %v\n", smallHash)
}
```

### Объяснение:
1. В данном примере используется хеш-функция **FNV** (хеш-функция с низкой коллизией), которая генерирует 32-битный хэш (это **полный хэш**).
2. Из полного хэша мы берём первые 8 бит (1 байт), которые служат **малым хэшом** для быстрого поиска внутри бакета.

Полный хэш используется для выбора бакета, а малый хэш — для поиска ключа внутри конкретного бакета.

---

### Полный текст с включённым примером:

Процесс роста и эвакуации в Go происходит, когда коэффициент загрузки карты превышает 6.5, что инициирует выделение нового массива бакетов, размер которого в два раза больше предыдущего. Во время этого Go входит в состояние, называемое "ростом", где происходит постепенная эвакуация. Это означает, что элементы из старых бакетов постепенно рехешируются и перемещаются в новый массив бакетов при каждой операции чтения или записи.

Go выполняет поиск и обновления, проверяя как старый, так и новый массив бакетов до тех пор, пока все бакеты не будут эвакуированы. Бакет помечается как "эвакуированный" после того, как все его пары ключ-значение были перенесены в новый массив. После завершения эвакуации старый массив бакетов отбрасывается, и для последующих операций используется только новый массив.

Go использует одно хэш-значение, которое используется для двух задач:
- **Большой хэш** — используется для выбора бакета (группы ключей).
- **Малый хэш** — используется для быстрого поиска ключа внутри выбранного бакета.

### Пример:

```go
package main

import (
	"fmt"
	"hash/fnv"
)

// Симуляция хеширования для ключей
func hashKey(key string) (uint32, uint8) {
	// Используем хеш-функцию FNV для генерации большого хэша
	h := fnv.New32a()
	h.Write([]byte(key))
	fullHash := h.Sum32()        // Большой хэш (full hash)
	smallHash := uint8(fullHash) // Малый хэш (1 байт из полного хэша)

	return fullHash, smallHash
}

func main() {
	key := "exampleKey"

	fullHash, smallHash := hashKey(key)
	fmt.Printf("Полный хэш: %v\n", fullHash)
	fmt.Printf("Малый хэш: %v\n", smallHash)
}
```

**Описание примера**:
1. Хеш-функция **FNV** генерирует полный хэш для ключа.
2. Полный хэш используется для выбора бакета.
3. Малый хэш (первые 8 бит) используется для быстрого поиска ключа внутри бакета.

Внутренние флаги бакетов указывают на их состояние:
- Пустой: Нет пар ключ-значение.
- Эвакуированный: Полностью перемещён в новый массив.
- Неэвакуированный: Всё ещё находится в старом массиве, ожидает переноса.

Если новый ключ добавляется во время фазы эвакуации и операции над старыми ключами не выполняются, Go продолжает работать с обоими массивами бакетов до завершения эвакуации. Если новый массив бакетов переполняется в этот период, процесс эвакуации продолжается наряду с управлением ростом бакетов.

Эвакуация отслеживается с помощью указателя или счётчика, который увеличивается по мере перемещения каждого бакета, гарантируя, что весь старый массив будет перенесён до его удаления. Когда Go встречает эвакуированный бакет во время чтения или записи, он использует маркер для перенаправления операций в новый массив бакетов.