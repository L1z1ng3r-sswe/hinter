## Пример работы с хэш-функцией

```go
package main

import (
	"fmt"
	"hash/fnv"
)

// Симуляция хэширования для ключей
func hashKey(key string) (uint32, uint8) {
	// Используем хэш-функцию FNV для генерации большого хэша
	h := fnv.New32a()
	h.Write([]byte(key))
	fullHash := h.Sum32()        // Большой хэш (full hash)
	smallHash := uint8(fullHash) // Малый хэш (1 байт из полного хэша)

	return fullHash, smallHash
}

func main() {
	key := "exampleKey"

	fullHash, smallHash := hashKey(key)
	fmt.Printf("Полный хэш: %v\n", fullHash)
	fmt.Printf("Малый хэш: %v\n", smallHash)
}
```

### Объяснение:
1. В примере используется хэш-функция **FNV**, которая генерирует 32-битное хэш-значение (**полный хэш**).
2. Из полного хэша берётся младший байт (**малый хэш**), который используется для поиска внутри бакета.
3. Полный хэш используется для определения бакета в хэш-таблице.

---

## Как работает эвакуация в мапах Go

Эвакуация данных в мапах Go происходит в следующих случаях:
- Когда коэффициент загрузки мапы превышает **6.5 элементов на бакет**, что указывает на необходимость увеличения размера таблицы.
- При увеличении размера мапы массив бакетов удваивается, и начинается процесс эвакуации.

### Основные этапы эвакуации:
1. Создаётся новый массив бакетов, размер которого в 2 раза больше текущего.
2. При каждой операции (`Get`, `Set`, `Delete`) один или несколько старых бакетов переносятся в новый массив.
3. Элементы из старых бакетов рехешируются и распределяются в новые бакеты.
4. Старый массив бакетов помечается как "эвакуированный" и удаляется после завершения переноса всех данных.

---

## Как работают операции во время эвакуации

### Чтение (`Get`) во время эвакуации:
1. **Сначала проверяются новые бакеты.**
   - Если ключ уже был перенесён, он будет найден в новом массиве.
2. **Если ключ не найден, проверяются старые бакеты.**
   - Если бакет ещё не эвакуирован, данные остаются в старом массиве.

### Пометка бакетов:
- Go использует внутренний счётчик или указатель `evacuateIndex`, чтобы отслеживать состояние эвакуации.
- Бакеты, которые полностью перенесены, помечаются как "эвакуированные".

### Оптимизация:
- Если операция чтения обнаруживает, что все ключи из старого бакета перенесены, бакет помечается как пустой.
- Операции чтения и записи всегда обращаются к обоим массивам (старому и новому), пока процесс эвакуации не завершится.

---

## Методы разрешения коллизий

В Go применяются следующие методы разрешения хэш-коллизий:
1. **Open addressing**:
   - Если ячейка бакета занята, выполняется линейное смещение к следующей ячейке до тех пор, пока не будет найдена пустая.
2. **Связные списки**:
   - Каждая ячейка бакета содержит указатель на связанный список ключей и значений.
3. **Бакеты**:
   - Каждый бакет содержит массив фиксированного размера (до 8 элементов) для хранения пар ключ-значение.

---

## Использование `sync.Map`

### Когда использовать:
- Когда мапа используется как кеш, который **только растёт**, с редкими изменениями.
- Когда несколько горутин читают и записывают данные для **несвязанных ключей**.

### Как это работает:
- `sync.Map` делится на две части: **read** и **dirty**:
  - **read** используется для быстрого чтения. Доступ к этой части выполняется без блокировок.
  - **dirty** используется для всех новых записей или изменения существующих данных.
- При записи новых данных они сначала добавляются в **dirty**. Если ключ часто запрашивается, он "продвигается" в **read**.
- Новые записи добавляются в **dirty** с использованием блокировки.
- Когда количество промахов (**misses**) при чтении из **read** превышает длину **dirty**, содержимое объединяется с **read**.
- После слияния **dirty** очищается, а чтения переключаются на обновлённую **read**.

### Пример работы:

#### Чтение:
1. При вызове `Load` сначала выполняется поиск в **read**.
2. Если ключ найден — возвращается значение.
3. Если ключа нет, выполняется поиск в **dirty** с использованием мьютекса.

#### Запись:
1. При вызове `Store` данные записываются в **dirty**.
2. Если ключа нет в **dirty**, он добавляется. Если ключ уже есть, значение обновляется.
3. Если количество **misses** превышает порог, содержимое **dirty** копируется в **read**.

### Ограничения:
- Неэффективно для частого чтения и записи **пересекающихся ключей**, так как каждое обновление вызывает копирование данных из **read** в **dirty**.