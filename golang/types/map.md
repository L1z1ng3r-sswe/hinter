## Пример работы с хэш-функцией

```go
package main

import (
	"fmt"
	"hash/fnv"
)

// Симуляция хэширования для ключей
func hashKey(key string) (uint32, uint8) {
	// Используем хэш-функцию FNV для генерации большого хэша
	h := fnv.New32a()
	h.Write([]byte(key))
	fullHash := h.Sum32()        // Большой хэш (full hash)
	smallHash := uint8(fullHash) // Малый хэш (1 байт из полного хэша)

	return fullHash, smallHash
}

func main() {
	key := "exampleKey"

	fullHash, smallHash := hashKey(key)
	fmt.Printf("Полный хэш: %v\n", fullHash)
	fmt.Printf("Малый хэш: %v\n", smallHash)
}
```

### Объяснение:
1. В примере используется хэш-функция **FNV**, которая генерирует 32-битное хэш-значение (**полный хэш**).
2. Из полного хэша берётся младший байт (**малый хэш**), который используется для поиска внутри бакета.
3. Полный хэш используется для определения бакета в хэш-таблице.

---

## Как работает эвакуация в мапах Go

Эвакуация данных в мапах Go происходит в следующих случаях:
- Когда коэффициент загрузки мапы превышает **6.5 элементов на бакет**, что указывает на необходимость увеличения размера таблицы.
- При увеличении размера мапы массив бакетов удваивается, и начинается процесс эвакуации.

### Основные этапы эвакуации:
1. Создаётся новый массив бакетов, размер которого в 2 раза больше текущего.
2. При каждой операции (`Get`, `Set`, `Delete`) один или несколько старых бакетов переносятся в новый массив.
3. Элементы из старых бакетов рехешируются и распределяются в новые бакеты.
4. Старый массив бакетов помечается как "эвакуированный" и удаляется после завершения переноса всех данных.

---

## Как работают операции во время эвакуации

### Чтение (`Get`) во время эвакуации:
1. **Сначала проверяются новые бакеты.**
   - Если ключ уже был перенесён, он будет найден в новом массиве.
2. **Если ключ не найден, проверяются старые бакеты.**
   - Если бакет ещё не эвакуирован, данные остаются в старом массиве.

### Пометка бакетов:
- Go использует внутренний счётчик или указатель `evacuateIndex`, чтобы отслеживать состояние эвакуации.
- Бакеты, которые полностью перенесены, помечаются как "эвакуированные".

### Оптимизация:
- Если операция чтения обнаруживает, что все ключи из старого бакета перенесены, бакет помечается как пустой.
- Операции чтения и записи всегда обращаются к обоим массивам (старому и новому), пока процесс эвакуации не завершится.

---

## Методы разрешения коллизий

В Go применяются следующие методы разрешения хэш-коллизий:
1. **Open addressing**:
   - Если ячейка бакета занята, выполняется линейное смещение к следующей ячейке до тех пор, пока не будет найдена пустая.
2. **Связные списки**:
   - Каждая ячейка бакета содержит указатель на связанный список ключей и значений.
3. **Бакеты**:
   - Каждый бакет содержит массив фиксированного размера (до 8 элементов) для хранения пар ключ-значение.

---

## Использование `sync.Map`

### Когда использовать:
- Когда мапа используется как кеш, который **только растёт**, с редкими изменениями.
- Когда несколько горутин читают и записывают данные для **несвязанных ключей**.

### Как это работает:
- `sync.Map` делится на две части: **immutable** (неизменяемая) и **mutable** (изменяемая).
- Новые записи добавляются в **mutable** с блокировкой.
- Когда чтения из `mutable` превышают пороговое значение (число операций больше длины `mutable`), содержимое объединяется с **immutable**.
- После слияния `mutable` очищается, а чтения переключаются на обновлённую `immutable`.

### Ограничения:
- Неэффективно для частого чтения и записи **пересекающихся ключей**, так как каждое обновление вызывает копирование данных из `mutable` в `immutable`.