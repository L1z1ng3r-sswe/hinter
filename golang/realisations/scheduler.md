Got it! Here's the fixed version with only the anchor IDs translated, while keeping the original content intact:

---

# Виды многозадачности

1. [Вытесняющая многозадачность](#preemptive-multitasking)
2. [Кооперативная многозадачность](#cooperative-multitasking)
3. [Многозадачность с разделением времени](#time-sharing-multitasking)
4. [Многозадачность реального времени](#real-time-multitasking)
5. [Параллелизм](#parallelism)
6. [Процессы и потоки](#processes-and-threads)

# Go Scheduler

1. [Горутины (Goroutines)](#goroutines)
2. [M (Тред, Machine)](#m-thread)
3. [P (Абстракция процессора, Processor)](#p-processor)
4. [G (Горутина, Goroutine)](#g-goroutine)
5. [Временное разделение (Time-Slicing)](#time-slicing)
6. [Кража работы (Work Stealing)](#work-stealing)

# Процессы и потоки

1. [Процессы](#processes)
2. [Потоки](#threads)
3. [Взаимосвязь процессов и потоков](#process-thread-relationship)
4. [Почему процессы создают потоки](#why-processes-create-threads)
5. [Преимущества и недостатки процессов и потоков](#pros-and-cons-of-processes-and-threads)

---

### Вытесняющая многозадачность <a id="preemptive-multitasking"></a>

При вытесняющей многозадачности операционная система прерывает задачи для их переключения, гарантируя, что каждая получает время процессора. Система использует таймер для сигнализации о том, когда приостановить одну задачу и начать другую.

### Кооперативная многозадачность <a id="cooperative-multitasking"></a>

При кооперативной многозадачности задачи сами решают, когда передать управление. ОС ожидает, пока каждая задача не завершит выполнение или добровольно не уступит управление. Одна задача может заблокировать систему, если не отдаст управление.

### Многозадачность с разделением времени <a id="time-sharing-multitasking"></a>

В многозадачности с разделением времени время процессора делится на интервалы, и каждая задача получает равную долю. После каждого интервала ОС переключается на другую задачу, создавая иллюзию одновременного выполнения.

### Многозадачность реального времени <a id="real-time-multitasking"></a>

Многозадачность реального времени гарантирует выполнение критических задач в пределах заданных временных рамок. Используется в системах, где важно выполнение задач вовремя, например в встраиваемых или критически важных системах.

### Параллелизм <a id="parallelism"></a>

Параллелизм предполагает выполнение нескольких задач одновременно на разных ядрах процессора. В отличие от многозадачности, где задачи выполняются поочередно, параллелизм позволяет выполнять их одновременно.

---

### Процессы <a id="processes"></a>

Процесс — это основная единица исполнения в операционной системе, которая содержит свое собственное адресное пространство и ресурсы. Каждый процесс работает независимо и может создавать дополнительные процессы или потоки для выполнения задач.

### Потоки <a id="threads"></a>

Поток — это легковесная единица исполнения, которая разделяет ресурсы (память, файлы) с другими потоками в рамках одного процесса. Потоки используются для многозадачности и позволяют более эффективно использовать ресурсы процессора.

### Взаимосвязь процессов и потоков <a id="process-thread-relationship"></a>

Процесс может создавать несколько потоков, которые будут работать параллельно и разделять ресурсы процесса. Потоки существуют внутри процесса и могут выполняться одновременно на разных ядрах процессора.

### Почему процессы создают потоки <a id="why-processes-create-threads"></a>

Процессы создают потоки для многозадачности и эффективного использования процессорных ресурсов. Потоки полезны для выполнения параллельных задач в рамках одного процесса, таких как обработка запросов на сервере или выполнение сложных вычислений.

### Преимущества и недостатки процессов и потоков <a id="pros-and-cons-of-processes-and-threads"></a>

**Процессы:**
- Преимущества: безопасность, изоляция, устойчивость к сбоям.
- Недостатки: высокая стоимость создания и переключения, сложность взаимодействия между процессами.

**Потоки:**
- Преимущества: легкость создания, возможность параллельного выполнения, низкая стоимость переключения контекста.
- Недостатки: отсутствие изоляции, необходимость синхронизации доступа к общим ресурсам, уязвимость к ошибкам в других потоках.

---

### Горутины (Goroutines) <a id="goroutines"></a>

Горутины — это легковесные единицы выполнения в Go, которые позволяют выполнять задачи параллельно без затрат на создание потоков ОС.

### M (Тред, Machine) <a id="m-thread"></a>

M — это реальный поток ОС, который выполняет горутины. Go использует несколько потоков ОС (M), чтобы запускать горутины параллельно на разных ядрах процессора.

### P (Абстракция процессора, Processor) <a id="p-processor"></a>

P — это абстракция планировщика в Go, которая содержит очередь готовых к выполнению горутин. P связывается с M (тредом) для выполнения горутин.

### G (Горутина, Goroutine) <a id="g-goroutine"></a>

G — это конкретная горутина. Она планируется на выполнение на P (абстракция процессора), который связан с M (потоком ОС) для выполнения.

### Временное разделение (Time-Slicing) <a id="time-slicing"></a>

Go использует кооперативную многозадачность, переключая горутины в определённые моменты, например, во время операций ввода-вывода или при явной передаче управления (например, `runtime.Gosched()`).

### Кража работы (Work Stealing) <a id="work-stealing"></a>

Если у одного P заканчиваются горутины, он может «украсть» их из очереди рандомного P, чтобы эффективно сбалансировать нагрузку. При этом очередь lockfree, и половина горутин переносится.

В Go размер локальной очереди каждого процессора (P) составляет 256 горутин. Если в локальной очереди нет места для новой горутины, она может быть добавлена в глобальную очередь, откуда неактивные процессоры могут взять работу.

Глобальная очередь также используется для выполнения задач. Каждые 61 «тик» процессоры могут пытаться украсть работу, проверяя глобальную очередь. В данном контексте «тик» означает момент, когда любой процессор может попытаться украсть работу у других, чтобы распределить задачи более равномерно.