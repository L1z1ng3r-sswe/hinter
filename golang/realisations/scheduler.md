# Go Scheduler

1. [Горутины (Goroutines)](#goroutines)
2. [G (Горутина, Goroutine)](#g-goroutine)
3. [M (Поток, Machine)](#m-thread)
4. [P (Абстракция процессора, Processor)](#p-processor)
5. [Временное разделение (Time-Slicing)](#time-slicing)
6. [Кража работы (Work Stealing)](#work-stealing)

---

### G (Горутина, Goroutine) <a id="g-goroutine"></a>

Переключение контекста в горутинах проще, потому что они работают в рамках одного потока ОС. Для переключения горутины нужно сохранить только указатель на текущую строку кода, маленький стек и минимальный набор регистров. Это всё делается в пользовательском пространстве без обращения к ядру. Потоки ОС, напротив, требуют системного вызова, сохранения большого стека и обращения к планировщику ОС, что занимает больше времени и ресурсов. Поэтому переключение горутин быстрее, проще и менее затратно.

Каждый поток имеет свою структуру, называемую Thread Control Block (Блок управления потоком). TCB — это объект в ядре ОС, который содержит всю важную информацию о потоке.
Пример информации в TCB:

Указатели на стек ядра и стек пользователя.
Регистры процессора.
Состояние потока: готов, выполняется, завершён, заблокирован и т.д.
Приоритет потока.
Идентификатор потока (Thread ID).
Ссылки на процесс, которому поток принадлежит.
Таймеры для планирования (если есть).

**G** — это конкретная горутина, которая представляет собой выполнение функции в Go. Горутины планируются на выполнение с использованием P (процессора) и M (потока ОС). Каждая горутина может находиться в одном из следующих состояний:
1. **Running** — горутина в данный момент выполняется на процессоре.
2. **Runnable** — готова к выполнению, но ожидает своей очереди.
3. **Waiting** — остановлена или заблокирована (например, при ожидании завершения системного вызова).

---

### M (Поток, Machine) <a id="m-thread"></a>

**M** (Machine) — это поток операционной системы, используемый для выполнения горутин. Планировщик Go может создавать и управлять несколькими потоками ОС (M) для распределения нагрузки на несколько процессорных ядер.

---

### P (Абстракция процессора, Processor) <a id="p-processor"></a>

**P** — это абстракция процессора, который содержит очередь готовых к выполнению горутин (runnable goroutines). Каждый P привязывается к одному M для выполнения горутин. 

**Ключевые моменты:**
1. Количество P задаётся с помощью `runtime.GOMAXPROCS`.
2. У P есть локальная очередь длиной 256 для выполнения горутин.
3. Если локальная очередь переполнена, горутины перемещаются в глобальную очередь.

Для предотвращения голодания (starvation), если горутина слишком долго ожидает доступа к локальной очереди, она получает приоритет.

---

### Временное разделение (Time-Slicing) <a id="time-slicing"></a>

Go использует **кооперативную многозадачность**:
1. Переключение горутин происходит при определённых событиях, например:
   - Операции ввода-вывода.
   - Вызов `runtime.Gosched()` для явной передачи управления.
2. Если горутина занимает процессор более 10 мс (например, бесконечный цикл), **sysmon** (системный монитор) принудительно приостанавливает её выполнение и передаёт управление другим горутинам.

---

### Кража работы (Work Stealing) <a id="work-stealing"></a>

Если локальная очередь P пуста, процессор может «украсть» горутины из другой очереди для эффективного распределения нагрузки. Механизм:
1. **Lock-free** структура: половина горутин из чужой локальной очереди переносится в локальную очередь текущего P.
2. Если попытка кражи повторяется 4 раза безуспешно, процессор проверяет глобальную очередь.

**Особенности:**
- Глобальная очередь проверяется каждые 61 «тиков» (вызовов планировщика).
- Горутины, созданные в процессе выполнения, остаются привязанными к текущему P.

---

### Работа с сетевыми операциями и системными вызовами

1. **Сетевые операции**:
   - Для сетевых вызовов Go использует механизм `netpoll`, основанный на платформенных инструментах: `epoll` (Linux), `kqueue` (macOS), `IOCP` (Windows).
   - Netpoll'ер паркует горутину: Если горутина блокируется на сетевом вызове (например, net.Conn.Read), она снимается с выполнения и помещается в очередь ожидания события. Освобождает поток ОС: Поток, на котором выполнялась горутина, освобождается для других задач. Обрабатывает события: Нет-поллер использует epoll, kqueue или IOCP для мониторинга сетевых событий.

2. **Системные вызовы**:
   - **Кратковременные вызовы**: могут блокировать P.
   - **Долговременные вызовы**:
     - M (поток) отвязывается от P для выполнения вызова.
     - На P выделяется новый или свободный поток из пула.
     - После завершения вызова поток возвращается в пул.

Системный монитор (**sysmon**) отслеживает кратковременные вызовы. Если они становятся долговременными, выполняется их обработка как для долговременных вызовов.
