# Garbage collector

1. [Стек и куча в ОЗУ](#стек-и-куча-в-озу)
2. [Сборщик мусора (GC) - алгоритм Mark and Sweep](#сборщик-мусора-gc---алгоритм-mark-and-sweep)
   - [Ключевые концепции GC](#ключевые-концепции-gc)
3. [Когда вызывается GC](#когда-вызывается-gc)
4. [Техники оптимизации](#техники-оптимизации)

---

### Стек и куча в ОЗУ

**Стек** и **куча** — это области памяти в ОЗУ, которые используются для разных задач:

- **Стек**:
  - Содержит локальные переменные, адреса возврата и временные данные.
  - Имеет фиксированный размер и не поддерживает динамическое выделение памяти.
  - Работает по принципу LIFO (последним пришёл — первым ушёл).

- **Куча**:
  - Используется для динамического выделения памяти.
  - Ограничивается только системными ресурсами (физической и виртуальной памятью).
  - Для управления памятью требуется сборщик мусора.

---

### Сборщик мусора (GC) - Алгоритм Mark and Sweep

Сборщик мусора в Go использует алгоритм **трёхцветной маркировки**: **белые**, **серые** и **чёрные** объекты.

#### Общий процесс работы GC:

1. **Инициализация**:
   - Все объекты изначально помечаются как белые (недостижимые).

2. **Сканирование корневых объектов**:
   - Глобальные переменные и ссылки из стека текущего потока определяются как корни.
   - Найденные объекты помечаются серыми и добавляются в **очередь серых объектов**.

3. **Сканирование серых объектов**:
   - Каждый объект из очереди серых сканируется, и все ссылки на другие объекты добавляются в ту же очередь.
   - После обработки объект перемещается в **чёрные объекты** (помеченные как достижимые).

4. **Удаление белых объектов**:
   - После завершения сканирования все оставшиеся белые объекты считаются недостижимыми и удаляются.

---

### Ключевые концепции GC

- **Write Barrier (барьер записи)**:
  - Обеспечивает целостность кучи при изменении объектов во время работы программы.
  - Помогает гарантировать, что чёрные объекты не ссылаются на белые.

- **Stop the World (STW)**:
  - Программа временно приостанавливается для выполнения определённых этапов GC, например, для финального сканирования.

---

### Когда вызывается GC

- **Ручной вызов**:
  - Можно вызвать GC вручную с помощью `runtime.GC()`, но это может заблокировать выполнение программы.

- **Динамическое управление**:
  - Pacer (механизм управления GC) вызывает сборщик мусора, когда размер кучи превышает определённый лимит.
  - Этот лимит можно изменить с помощью переменной окружения `GOGC`.

#### Процесс вызова GC:

1. Получение сигнала запуска GC. Если предыдущая очистка не завершена, ожидается её завершение.
2. Останавливаются только те горутины, которые находятся в "небезопасных" точках, остальные продолжают выполнение.
3. Включается **барьер записи** и запускается трёхцветный алгоритм:
   - Глобальные переменные и стеки горутин сканируются, объекты маркируются.
   - Сканирование стека требует остановки конкретной горутины на время обработки.

4. После завершения трёхцветного алгоритма начинается этап `_GCmarktermination`:
   - Остановка мира (Stop the World).
   - Завершаются последние задачи, очищаются кэши. Полностью избегать остановки мира сложно, поэтому разработчики допускают небольшие остановки.

5. Финальный этап:
   - `_GCoff`: сборщик мусора отключается.
   - Отключается барьер записи.
   - Программа возобновляет работу, фоновая очистка завершается.

---

### Недостатки (Cons and Flaws)

- Отсутствие алгоритмов поколений (generational GC).
- Неэффективность полной остановки мира (STW).
- Ограниченные возможности настройки (только переменная `GOGC`).

---

### Техники оптимизации

1. **Изменение переменной `GOGC`**:
   - Увеличение значения изменяет порог размера кучи. Например, `GOGC=200` позволяет рост кучи в 2 раза перед запуском GC.

2. **Использование `sync.Pool`**:
   - Для временных объектов, которые можно переиспользовать, вместо их повторного создания.

3. **Создание "балласта"**:
   ```go
   ballast := make([]byte, 10<<30)
   ```
   - Увеличивает базовый размер кучи, уменьшая частоту вызовов GC. Если "балласт" не используется, память выделяется только виртуально.

---

### Почему нужен стек?

Пример:
```go
func main() {
   x := getValue()
   fmt.Println(*x)
}

func getValue() *int {
   x := 4
   return &x
}
```

Без кучи программа выдала бы ошибку, так как переменная `x` после выхода из функции удаляется из стека. Это приводит к созданию **dangling pointer** (висячей ссылки).

---

### Анализ утечек (Escape Analysis)

Go решает, где хранить переменную (в стеке или куче), с помощью анализа утечек.

**На куче сохраняются переменные, если:**
- Возвращается указатель на значение.
- Переменная используется за пределами её области видимости.

**Команда для анализа:**
```bash
go build -gcflags "-m"
go build -gcflags "-m=2 -l"
```

**Пример вывода:**
```bash
./main.go:12:10: i does not escape
./main.go:9:14: x escapes to heap:
```

Анализ выполняется во время компиляции, чтобы минимизировать утечки памяти.