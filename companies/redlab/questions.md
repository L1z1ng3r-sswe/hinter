## Questions

1. [What is SOLID?](#what-is-solid)
2. [Как добиться высокого уровня тестового покрытия и стабильности?](#high-test-coverage)
3. [DDD: На что мы подписываемся и что теряем?](#ddd-pros-cons)
4. [3 порождающих паттерна](#creational-patterns)
5. [В какой части Синглтон может быть антипаттерном?](#singleton-antipattern)
6. [Микросервисная архитектура: лучше монолита, риски и хуже монолит]
7. [2 крайних случая интерфейса (Fat and Empty Interface)](#interface-edge-cases)
8. [GRPC, две части которого часто находятся в одном файле (messages and methods)]

---

## Answers

### What is SOLID? <a id="what-is-solid"></a>

---

### Как добиться высокого уровня тестового покрытия и стабильности? <a id="high-test-coverage"></a>

Чтобы добиться высокого уровня тестового покрытия и стабильности, можно использовать следующие подходы:
- **God Object**: Следует избегать "божественных объектов", которые концентрируют в себе слишком много обязанностей. Это делает тестирование сложным.
- **Mock Objects**: Использование объектов-заглушек (Mock) помогает изолировать тестируемый код от внешних зависимостей, что увеличивает стабильность тестов и их охват. Моки позволяют тестировать компоненты независимо друг от друга.

---

### DDD: На что мы подписываемся и что теряем? <a id="ddd-pros-cons"></a>

#### Плюсы:
- **Фиксация требований в коде**: Применяя DDD, мы стремимся к тому, чтобы требования непосредственно отражались в коде. Этот подход позволяет заранее определить тесты для еще не существующего кода, а затем разрабатывать код, который соответствует этим тестам. Это обеспечивает более тесное соответствие бизнес-логики с реализацией, а также способствует лучшему тестовому покрытию и качеству кода.

#### Минусы:
- **Неполнота требований**: Одним из ключевых недостатков является тот факт, что требования могут не в полной мере отражать реальность бизнеса. Это может быть связано с недостаточным взаимодействием с экспертами предметной области или же изменением бизнес-приоритетов после разработки требований. В результате мы разрабатываем тесты и код, основанные на этих неполных требованиях, что приводит к необходимости их переписывания. Это создает риск увеличения сроков и затрат на проект.

---

### 3 порождающих паттерна <a id="creational-patterns"></a>

1. **Фабрика** (простая и абстрактная)  
2. **Строитель**  
3. **Прототип**

---

### In what part Singleton can be antipattern? <a id="singleton-antipattern"></a>

#### Нарушение принципа единственной ответственности (SRP)

Singleton часто берет на себя несколько обязанностей, выходя за рамки управления единственным экземпляром. Вместо того чтобы ограничиваться созданием и контролем доступа к одному объекту, Singleton может начать выполнять задачи, которые логически должны находиться в других компонентах системы. Это увеличивает сложность класса и делает его труднее поддерживаемым.

#### Скрытые зависимости и побочные эффекты

Singleton создает глобально доступный объект, на который могут начать полагаться различные части системы. Это порождает скрытые зависимости, усложняя отладку и понимание кода. Любое изменение в Singleton может вызвать неожиданные побочные эффекты в других частях системы.

#### Трудности с расширением и масштабированием

Singleton ограничивает возможность масштабирования системы, особенно в распределенных средах. Поддержание единственного экземпляра может стать узким местом, а синхронизация состояний между различными экземплярами приводит к дополнительным накладным расходам на разработку и снижению производительности.

--- 

### 2 крайних случая интерфейса (Fat and Empty Interface) <a id="interface-edge-cases"></a>

### Толстый интерфейс (Fat Interface) violation of interface segregation principle (ISP)

**Описание**: Толстый интерфейс (Fat Interface) — это интерфейс, который содержит слишком много методов. Такие интерфейсы часто называют "интерфейсами, знающими слишком много". В данном случае один интерфейс берёт на себя множество обязанностей, что нарушает принцип единственной ответственности (SRP) и делает его сложным для реализации.

**Плюсы**:
- **Гибкость**: Объекты, реализующие толстый интерфейс, могут предложить множество возможностей и объединять разные аспекты функциональности в одном интерфейсе.

**Минусы**:
- **Сложность в реализации**: Все методы интерфейса должны быть реализованы, даже если некоторые из них не нужны в конкретной реализации.
- **Трудность в поддержке**: Изменение в одном методе может привести к необходимости пересмотра всех реализаций интерфейса, что делает его трудным для поддержания.

**Пример толстого интерфейса**:

```go
type Database interface {
    Connect() error
    ReadData() ([]byte, error)
    WriteData([]byte) error
    Close() error
    Backup() error
    Restore() error
}
```
Этот интерфейс объединяет несколько обязанностей, таких как управление подключением, чтение/запись данных и резервное копирование, что делает его перегруженным.

### Пустой интерфейс (Empty Interface) 

**Описание**: Пустой интерфейс в Go (`interface{}`) — это интерфейс, который не определяет никаких методов. Он является универсальным интерфейсом, поскольку **любой тип** в Go реализует пустой интерфейс. Это делает его удобным для обработки данных различных типов.

**Плюсы**:
- **Гибкость**: Пустой интерфейс позволяет принимать значения любого типа, что полезно в случаях, когда тип данных заранее неизвестен (например, структуры `map` или `slice` с элементами разных типов).
  
**Минусы**:
- **Отсутствие типовой безопасности**: Так как типы данных не определены, нужно использовать **type assertion** или **type switch** для работы с ними, что может привести к ошибкам времени выполнения.
- **Усложнение кода**: Частое использование пустого интерфейса может сделать код трудным для понимания и поддержки, поскольку необходимо явно проверять типы данных.

**Пример пустого интерфейса**:

```go
func PrintAnything(i interface{}) {
    fmt.Println(i)
}

func main() {
    PrintAnything(42)         // int
    PrintAnything("hello")    // string
    PrintAnything(true)       // bool
}
```
Функция `PrintAnything` может принимать аргументы любого типа благодаря использованию пустого интерфейса.

---

### Сравнение:
- **Толстый интерфейс** требует реализации множества методов, что делает его сложным и перегруженным.
- **Пустой интерфейс** слишком абстрактен, что приводит к потере типовой безопасности, и требует дополнительных проверок типов.

Теперь у вас есть полное описание с якорями для **толстого** и **пустого** интерфейсов.